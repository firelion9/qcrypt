package com.firelion.crystals.util

import com.firelion.crystals.util.KyberParams.Companion.KYBER_SYMMETRIC_BYTES

/**
 * Generates a key pair for Kyber with parameters set [params].
 * Writes results to first [KyberParams.KYBER_PUBLIC_KEY_BYTES] of [publicKey] and
 * first [KyberParams.KYBER_PRIVATE_KEY_BYTES] of [privateKey].
 *
 * @see [kexUakeInitA], [kexAkeInitA], [KyberParams]
 */
fun kexKeyPair(publicKey: ByteArray, privateKey: ByteArray, params: KyberParams) {
    cryptoKemKeyPair(publicKey, privateKey, params)
}

/**
 * Initializes an unilaterally authenticated key exchange (only Bob (second side) would be authenticated).
 * Should be executed by Alice (first side).
 *
 * Generates temporal data for shared secret generation and a package, which should be sent to Bob,
 * from his pubic key [publicKeyB], Alice's privateKey [privateKeyA] and parameters set [params].
 * Writes the data to first [KyberParams.KYBER_SHARED_SECRET_BYTES] of [tk] and
 * the package to first [KyberParams.KEX_UAKE_SEND_A_BYTES] bytes of [sendA].
 *
 * @see [kexKeyPair], [kexUakeSharedB], [kexUakeSharedA]
 */
fun kexUakeInitA(sendA: ByteArray, tk: ByteArray, privateKeyA: ByteArray, publicKeyB: ByteArray, params: KyberParams) {
    cryptoKemKeyPair(sendA, privateKeyA, params)
    cryptoKemEncrypt(publicKeyB, sendA, params.KYBER_PUBLIC_KEY_BYTES, tk, 0, params)
}

/**
 * Should be executed by Bob (second side) on the second step of an unilaterally authenticated key exchange.
 *
 * Generates a shared secret and a package, which should be sent to Alice (first side),
 * from her package [rcv], Bob's privateKey [privateKeyB] and parameters set [params].
 * Writes the shared secret to first [KyberParams.KYBER_SHARED_SECRET_BYTES] of [k] and
 * the package to first [KyberParams.KEX_UAKE_SEND_B_BYTES] bytes of [sendB].
 *
 * @see [kexKeyPair], [kexUakeInitA], [kexUakeSharedA]
 */
fun kexUakeSharedB(sendB: ByteArray, k: ByteArray, rcv: ByteArray, privateKeyB: ByteArray, params: KyberParams) {
    val buf = ByteArray(2 * KYBER_SYMMETRIC_BYTES)

    cryptoKemEncrypt(rcv, sendB, 0, buf, 0, params)
    cryptoKemDecrypt(privateKeyB, buf, KYBER_SYMMETRIC_BYTES, rcv, params.KYBER_PUBLIC_KEY_BYTES, params)

    params.kdf(k, 0, buf, 2 * KYBER_SYMMETRIC_BYTES)
}

/**
 * Should be executed by Alice (first side) on the third step of an unilaterally authenticated key exchange.
 *
 * Generates a shared secret from Bob's (second side) package [rcv], Alice's privateKey [privateKeyA],
 * data from the first step [tk] and parameters set [params].
 * Writes the shared secret to first [KyberParams.KYBER_SHARED_SECRET_BYTES] of [k].
 * This shared secret would be equal to shared secret, generated by Bob on the second step
 * (excluding unlikely situations when it is not passable to recover secret correctly).
 *
 * @see [kexKeyPair], [kexUakeInitA], [kexUakeSharedB]
 */
fun kexUakeSharedA(k: ByteArray, rcv: ByteArray, tk: ByteArray, privateKeyA: ByteArray, params: KyberParams) {
    val buf = ByteArray(2 * KYBER_SYMMETRIC_BYTES)

    cryptoKemDecrypt(privateKeyA, buf, 0, rcv, 0, params)
    System.arraycopy(tk, 0, buf, KYBER_SYMMETRIC_BYTES, KYBER_SYMMETRIC_BYTES)

    params.kdf(k, 0, buf, 2 * KYBER_SYMMETRIC_BYTES)
}

/**
 * Initializes a mutually authenticated key exchange.
 * Should be executed by Alice (first side).
 *
 * Generates temporal data for shared secret generation, ephemeral private key and
 * a package, which should be sent to Bob,
 * from his pubic key [publicKeyB] and parameter set [params].
 * Writes the data to first [KyberParams.KYBER_SHARED_SECRET_BYTES] of [tk],
 * the package to first [KyberParams.KEX_AKE_SEND_A_BYTES] bytes of [sendA] and
 * the ephemeral private key to first [KyberParams.KYBER_PRIVATE_KEY_BYTES] of [privateKey].
 *
 * @see [kexKeyPair], [kexAkeSharedB], [kexAkeSharedA]
 */
fun kexAkeInitA(sendA: ByteArray, tk: ByteArray, privateKey: ByteArray, publicKeyB: ByteArray, params: KyberParams) {
    cryptoKemKeyPair(sendA, privateKey, params)
    cryptoKemEncrypt(publicKeyB, sendA, params.KYBER_PUBLIC_KEY_BYTES, tk, 0, params)
}

/**
 * Should be executed by Bob (second side) on the second step of a mutually authenticated key exchange.
 *
 * Generates a shared secret and a package, which should be sent to Alice (first side),
 * from her package [rcv] and public key [publicKeyA],
 * Bob's privateKey [privateKeyB] and parameter set [params].
 * Writes the shared secret to first [KyberParams.KYBER_SHARED_SECRET_BYTES] of [k] and
 * the package to first [KyberParams.KEX_AKE_SEND_B_BYTES] bytes of [sendB].
 *
 * @see [kexKeyPair], [kexAkeInitA], [kexAkeSharedA]
 */
fun kexAkeSharedB(
    sendB: ByteArray,
    k: ByteArray,
    rcv: ByteArray,
    privateKeyB: ByteArray,
    publicKeyA: ByteArray,
    params: KyberParams
) {
    val buf = ByteArray(3 * KYBER_SYMMETRIC_BYTES)

    cryptoKemEncrypt(rcv, sendB, 0, buf, 0, params)
    cryptoKemEncrypt(publicKeyA, sendB, params.KYBER_CIPHER_TEXT_BYTES, buf, KYBER_SYMMETRIC_BYTES, params)
    cryptoKemDecrypt(
        privateKeyB,
        buf,
        2 * KYBER_SYMMETRIC_BYTES,
        rcv,
        params.KYBER_PUBLIC_KEY_BYTES,
        params
    )

    params.kdf(k, 0, buf, 3 * KYBER_SYMMETRIC_BYTES)
}

/**
 * Should be executed by Alice (first side) on the third step of a mutually authenticated key exchange.
 *
 * Generates a shared secret from Bob's (second side) package [rcv],
 * Alice's privateKey [privateKeyA], the data from the first step [tk],
 * ephemeral private key (from first step) [privateKey] and parameter set [params].
 * Writes the shared secret to first [KyberParams.KYBER_SHARED_SECRET_BYTES] of [k].
 * This shared secret would be equal to shared secret, generated by Bob on the second step
 * (excluding unlikely situations when it is not passable to recover secret correctly).
 *
 * @see [kexKeyPair], [kexAkeInitA], [kexAkeSharedB]
 */
fun kexAkeSharedA(
    k: ByteArray,
    rcv: ByteArray,
    tk: ByteArray,
    privateKey: ByteArray,
    privateKeyA: ByteArray,
    params: KyberParams
) {
    val buf = ByteArray(3 * KYBER_SYMMETRIC_BYTES)

    cryptoKemDecrypt(privateKey, buf, 0, rcv, 0, params)
    cryptoKemDecrypt(privateKeyA, buf, KYBER_SYMMETRIC_BYTES, rcv, params.KYBER_CIPHER_TEXT_BYTES, params)
    System.arraycopy(tk, 0, buf, 2 * KYBER_SYMMETRIC_BYTES, KYBER_SYMMETRIC_BYTES)

    params.kdf(k, 0, buf, 3 * KYBER_SYMMETRIC_BYTES)
}
